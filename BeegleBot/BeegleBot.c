#pragma config(Sensor, dgtl1,  jumperLeft,     sensorDigitalIn)
#pragma config(Motor,  port1,           FLDrive,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           BLDrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FRDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           BRDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LLLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LRLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           ULLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           URLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          BottomPushBar, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"//gets the vex competition package

bool left;

void LDrive(int prw)
{
	motor[BLDrive] = motor[FLDrive] = prw;
}
void RDrive(int prw)//function to turn on the right drive
{
	motor[BRDrive] = motor[FRDrive] = prw;
}
void lift(int pwr)//function for the lift
{
	motor[LLLift] = motor[LRLift] = motor[ULLift] = motor[URLift] = pwr;
}
void pushBar(int pwr)
{
	motor[BottomPushBar] = pwr;
}
void claw(int pwr)
{
	motor[Claw] = pwr;
}
void checkSide()
{
	if(SensorValue[jumperLeft] != 0)
		left = false;
	else
		left = true;
}
void goRobit(int pwrR, int pwrL, int time)
{
	LDrive(pwrL);
	RDrive(pwrR);
	wait1Msec(time);
	LDrive(0);
	RDrive(0);
}
void goRobit(int pwrR, int pwrL, int time, bool useLeftSwitcher)
{
	if(useLeftSwitcher && left)
	{
		pwrR *= -1;
		pwrL *= -1;
	}
	LDrive(pwrL);
	RDrive(pwrR);
	wait1Msec(time);
	LDrive(0);
	RDrive(0);
}
void goLift(int pwr, int time)
{
	lift(pwr);
	wait1Msec(time);
	lift(0);
}
void goClaw(int pwr, int time)
{
	claw(pwr);
	wait1Msec(time);
	claw(0);
}
void goPushBar(int pwr, int time)
{
	pushBar(pwr);
	wait1Msec(time);
	pushBar(0);
}
//Drive options
void arcade(int move, int rot)
{
	LDrive(move + rot);
	RDrive(move - rot);
}
void tank(int pwrL, int pwrR)
{
	LDrive(pwrL);
	RDrive(pwrR);
}

void pre_auton()
{

}

task autonomous()
{
	checkSide();
	goRobit(127, 127, 1000);
	goRobit(127, -127, 1000, true);
	goRobit(-127, 127, 1000, true);
	left = true;
	goRobit(127, -127, 1000, true);
	goRobit(-127, 127, 1000, true);
	goRobit(127, 127, 1000);
	goRobit(-127, 127, 1000);
}

task usercontrol()
{
	while(true)
	{
		arcade(vexRT[Ch3], vexRT[Ch1]);
	}
}
